<script>
    // Global variables (ensure these are at the top of your script)
    let i18nData = {};
    let currentSelectedLang = 'en';
    let questionsData = [];
    let competenciesData = [];
    let overallProficiencyLevelsData = [];
    const answers = { Knowledge: [], Skills: [], Attitudes: [] };
    let currentIndex = 0;
    let radarChart;

    // DOM Element Grabbers (will be assigned after DOM is loaded)
    let startScreen, assessmentScreen, endScreen, progressBar, progressLabel, competencyBanner,
        questionTextContainer, exampleTextContainer, proficiencyButtonsNodeList, noSelectionWarningEl, // Renamed proficiencyButtons to proficiencyButtonsNodeList to avoid conflict
        strengthsContainer, growthAreasContainer, smartObjectivesContainer,
        restartButton, startButton, langSelectorElement;


    function assignDOMelements() {
        startScreen = document.getElementById("start-screen");
        assessmentScreen = document.getElementById("assessment-screen");
        endScreen = document.getElementById("end-screen");
        progressBar = document.getElementById("progress-bar");
        progressLabel = document.getElementById("progress-label");
        competencyBanner = document.getElementById("competency-banner");
        questionTextContainer = document.getElementById("question-text-container");
        exampleTextContainer = document.getElementById("example-text-container");
        // proficiencyButtonsNodeList will be populated and re-queried in populateProficiencyButtons
        noSelectionWarningEl = document.getElementById("no-selection-warning");
        strengthsContainer = document.getElementById("strengths");
        growthAreasContainer = document.getElementById("growth-areas");
        smartObjectivesContainer = document.getElementById("smart-objectives");
        restartButton = document.getElementById("restart-button");
        startButton = document.getElementById("start-button");
        langSelectorElement = document.getElementById('language-selector');
    }

    function setText(id, text) {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = text;
        } else {
            // console.warn(`Element with ID '${id}' not found for setText: ${text}`);
        }
    }

    function setHTML(id, html) {
        const el = document.getElementById(id);
        if (el) {
            el.innerHTML = html;
        } else {
            // console.warn(`Element with ID '${id}' not found for setHTML: ${html}`);
        }
    }

    function t(key, replacements = {}) {
        if (typeof i18nData !== 'object' || i18nData === null) {
            return `MISSING_I18NDATA: ${key}`;
        }
        let textValue = i18nData;
        const parts = key.split('.');
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (textValue && typeof textValue === 'object' && Object.prototype.hasOwnProperty.call(textValue, part)) {
                textValue = textValue[part];
            } else {
                return `MISSING_TRANSLATION: ${key}`; 
            }
        }
        if (typeof textValue !== 'string') {
            return `INVALID_TRANSLATION_TYPE: ${key}`;
        }
        let finalText = textValue;
        for (const placeholder in replacements) {
            finalText = finalText.replace(new RegExp(`{${placeholder}}`, 'g'), replacements[placeholder]);
        }
        return finalText;
    }

    async function loadTranslations(langCodeToTry) {
        // console.log(`loadTranslations CALLED for lang: ${langCodeToTry}`);
        let langToLoad = langCodeToTry.toLowerCase().split('-')[0]; 
        if (langCodeToTry.toLowerCase() === 'zh-hans') langToLoad = 'zh-hans';
        if (langCodeToTry.toLowerCase() === 'zh-hant') langToLoad = 'zh-hant';
        
        let response;

        try {
            response = await fetch(`${langToLoad}.json?v=${new Date().getTime()}`);
            if (!response.ok) {
                console.warn(`Could not load ${langToLoad}.json (Status: ${response.status}). Falling back to English.`);
                if (langToLoad === 'en') { 
                    throw new Error('Critical: Failed to load en.json. Application cannot start.');
                }
                langToLoad = 'en'; 
                response = await fetch(`en.json?v=${new Date().getTime()}`);
                if (!response.ok) {
                    throw new Error('Critical: Failed to load en.json as fallback. Application cannot start.');
                }
            }
            i18nData = await response.json();
            // console.log('Successfully loaded i18nData for:', langToLoad); // Simplified log
            
            currentSelectedLang = langToLoad; 
            document.documentElement.lang = currentSelectedLang;
            document.title = t('appTitle'); 

            questionsData = i18nData.questions || [];
            competenciesData = i18nData.competencyList || [];
            overallProficiencyLevelsData = i18nData.overallProficiencyLevels || [];
            
            if (competenciesData && competenciesData.length > 0) {
                const numCompetencies = competenciesData.length;
                answers.Knowledge = Array(numCompetencies).fill(0);
                answers.Skills = Array(numCompetencies).fill(0);
                answers.Attitudes = Array(numCompetencies).fill(0);
            } else {
                console.error("Competencies data is empty. Answers not initialized.");
            }

            applyTranslations(); 
            updateLanguageSelectorValue(currentSelectedLang); 
            localStorage.setItem('selectedUserLanguage', currentSelectedLang); 

            console.log(`${currentSelectedLang.toUpperCase()} translations applied successfully.`);

        } catch (error) {
            console.error("Fatal error loading translation file:", error);
            document.body.innerHTML = `<div style="padding: 20px; text-align: center; font-family: sans-serif;"><h1>Error</h1><p>Could not load required resources. Please try again. Details: ${error.message}</p></div>`;
        }
    }
    
    function updateLanguageSelectorValue(langCode) {
        if (!langSelectorElement) {
            // console.warn("Language selector element not available for updateLanguageSelectorValue");
            return;
        }
        langSelectorElement.value = langCode;
        const label = document.getElementById('language-selector-label');
        if (label) {
            const labelText = t('misc.languageLabel'); // Ensure 'misc.languageLabel' exists in your JSON files
            label.textContent = labelText.startsWith('MISSING_') ? 'Language:' : labelText;
        }
    }

    function applyTranslations() {
        // console.log("applyTranslations CALLED for lang:", currentSelectedLang);
        
        // Update language selector label immediately
        const langLabel = document.getElementById('language-selector-label');
        if (langLabel) {
            const labelText = t('misc.languageLabel');
            langLabel.textContent = labelText.startsWith('MISSING_') ? 'Language:' : labelText;
        }

        // Start Screen
        setText('start-screen-title', t('startScreen.title'));
        setHTML('start-screen-p1', t('startScreen.introParagraph1'));
        setHTML('start-screen-p2', t('startScreen.introParagraph2'));
        setHTML('start-screen-p3', t('startScreen.introParagraph3'));
        setHTML('start-screen-p4', t('startScreen.introParagraph4'));
        if (startButton) setText('start-button', t('startScreen.startButtonText'));

        // Assessment Screen elements
        if (noSelectionWarningEl) setText('no-selection-warning', t('assessmentScreen.noSelectionWarning'));
        const toggleProfButton = document.getElementById('toggle-proficiency-button');
        if (toggleProfButton) {
            const proficiencyDropdownEl = document.getElementById('proficiency-dropdown-content');
            if (proficiencyDropdownEl && (proficiencyDropdownEl.style.display === "none" || proficiencyDropdownEl.style.display === "")) {
                toggleProfButton.textContent = t('assessmentScreen.showProficiencyLevelsButton');
            } else if (proficiencyDropdownEl) {
                toggleProfButton.textContent = t('assessmentScreen.hideProficiencyLevelsButton');
            }
        }
        const proficiencyDropdown = document.getElementById('proficiency-dropdown-content');
        if (proficiencyDropdown) {
            proficiencyDropdown.innerHTML = `
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.beginner')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.developing')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.competent')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.proficient')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.expert')}</p>
            `;
        }
        populateProficiencyButtons();

        // Re-render current question if on assessment screen
        if (assessmentScreen && !assessmentScreen.classList.contains('hidden') && questionsData.length > 0 && currentIndex < questionsData.length) {
            renderQuestion(currentIndex); 
        }

        // End Screen static texts
        setText('end-screen-title', t('endScreen.title'));
        setText('qr-code-title', t('endScreen.qrCodeSectionTitle'));
        setText('qr-code-instruction', t('endScreen.qrCodeInstruction'));
        setText('key-char-title', t('endScreen.keyCharacteristicsTitle'));
        setText('key-char-intro', t('endScreen.keyCharacteristicsIntro'));
        setText('radar-chart-title', t('endScreen.radarChartTitle'));
        setText('radar-chart-desc', t('endScreen.radarChartDescription'));
        setHTML('radar-chart-legend', constructRadarLegend());
        setHTML('strengths-title', t('endScreen.strengthsSectionTitle'));
        setText('strengths-intro', t('endScreen.strengthsSectionIntro'));
        setHTML('growth-areas-title', t('endScreen.growthAreasSectionTitle'));
        setText('growth-areas-intro', t('endScreen.growthAreasSectionIntro'));
        setHTML('smart-objectives-title', t('endScreen.smartObjectivesSectionTitle'));
        setText('smart-objectives-intro', t('endScreen.smartObjectivesSectionIntro'));
        setHTML('thank-you-message', t('endScreen.thankYouMessage'));
        setText('survey-prompt', t('endScreen.surveyPrompt'));
        setText('survey-button', t('endScreen.surveyButtonText'));
        if (restartButton) setText('restart-button', t('endScreen.restartButtonText'));
        
        // If end screen is visible and results were previously generated, regenerate dynamic content
        if (endScreen && !endScreen.classList.contains('hidden') && (answers.Knowledge.length > 0 || answers.Skills.length > 0 || answers.Attitudes.length > 0)) {
            console.log("End screen visible and has answers, re-generating results page content for new language.");
            generateResultsPageContent();
        }
    }

    // --- (The rest of your JavaScript functions: constructRadarLegend, populateProficiencyButtons, assessment logic, results generation, etc., remain largely the same as the version that correctly logged the dimension names) ---
    // Make sure they use the globally defined DOM element variables that are now assigned in assignDOMelements().
    // I will re-paste the full script from the last known good state and then make necessary adjustments.

    function constructRadarLegend() {
        const andConj = t('misc.andConjunction');
        const lowerThanConj = t('misc.areLowerThanConjunction');
        return `${t('endScreen.radarChartLegendIntro')}
                <span style="color: #ff6384; font-weight: bold;">${t('endScreen.radarChartLegendKnowledge')}</span>,
                <span style="color: #36a2eb; font-weight: bold;">${t('endScreen.radarChartLegendSkills')}</span>, ${andConj.startsWith('MISSING_') ? 'and' : andConj}
                <span style="color: #4bc0c0; font-weight: bold;">${t('endScreen.radarChartLegendAttitudes')}</span>
                ${t('endScreen.radarChartLegendExplanation')}
                <span style="color: #36a2eb; font-weight: bold;">${t('endScreen.radarChartLegendSkillsExample')}</span>
                ${lowerThanConj.startsWith('MISSING_') ? 'are lower than' : lowerThanConj} <span style="color: #ff6384; font-weight: bold;">${t('endScreen.radarChartLegendKnowledgeExample')}</span>
                ${t('endScreen.radarChartLegendExplanationSuffix')}`;
    }

    function populateProficiencyButtons() {
        const container = document.querySelector('#assessment-screen .proficiency-buttons');
        if (!container) return;
        container.innerHTML = '';
        for (let i = 1; i <= 5; i++) {
            const button = document.createElement('button');
            button.classList.add('proficiency-button');
            button.setAttribute('data-value', i);
            button.type = 'button';
            button.textContent = t(`proficiencyLabels.${i}`); 
            container.appendChild(button);
        }
        proficiencyButtonsNodeList = document.querySelectorAll("#assessment-screen .proficiency-button"); 
    }

    function getCompetencyNameByKey(key) {
        if (!competenciesData) return `NO_COMP_DATA_FOR_KEY: ${key}`;
        const competency = competenciesData.find(c => c.key === key);
        return competency ? competency.name : `MISSING_COMP_NAME: ${key}`;
    }

    function renderQuestion(index) {
        // console.log(`renderQuestion CALLED for index: ${index}`);
        if (!questionsData || questionsData.length === 0 || index >= questionsData.length) {
            console.error("Questions data issue or index out of bounds in renderQuestion.", { qDataLength: questionsData?.length, index });
            return;
        }
        const question = questionsData[index];
        const competencyName = getCompetencyNameByKey(question.competencyKey);
        const examplePrefixText = t('misc.examplePrefix');

        if (competencyBanner) competencyBanner.textContent = `${t('assessmentScreen.competencyBannerPrefix')}${competencyName}`;
        if (questionTextContainer) questionTextContainer.textContent = t(`questionTexts.${question.questionKey}`);
        if (exampleTextContainer) exampleTextContainer.textContent = `${examplePrefixText.startsWith("MISSING_") ? "Example: " : examplePrefixText}${t(`questionTexts.${question.exampleKey}`)}`;

        const progressPercentage = Math.round(((index + 1) / questionsData.length) * 100);
        if (progressBar) progressBar.style.width = `${progressPercentage}%`;
        if (progressLabel) progressLabel.textContent = `${progressPercentage}${t('assessmentScreen.progressLabelSuffix')}`;
        
        proficiencyButtonsNodeList = document.querySelectorAll("#assessment-screen .proficiency-button"); // Re-query in case they were just populated
        proficiencyButtonsNodeList.forEach(button => button.classList.remove("selected"));
        
        if(noSelectionWarningEl) noSelectionWarningEl.style.display = 'none';
        attachEventListeners();
    }

    function attachEventListeners() {
        // console.log("attachEventListeners CALLED");
        proficiencyButtonsNodeList = document.querySelectorAll("#assessment-screen .proficiency-button"); // Ensure we have the latest buttons
        
        proficiencyButtonsNodeList.forEach(button => {
            const newButton = button.cloneNode(true); 
            if (button.parentNode) {
                button.parentNode.replaceChild(newButton, button);
            }
        });
        proficiencyButtonsNodeList = document.querySelectorAll("#assessment-screen .proficiency-button"); 

        proficiencyButtonsNodeList.forEach(button => {
            button.onclick = () => {
                if(noSelectionWarningEl) noSelectionWarningEl.style.display = 'none';
                proficiencyButtonsNodeList.forEach(btn => btn.classList.remove("selected"));
                button.classList.add("selected");
                const selectedValue = parseInt(button.getAttribute("data-value"));
                const currentQuestion = questionsData[currentIndex];
                const competencyIndex = competenciesData.findIndex(c => c.key === currentQuestion.competencyKey);

                if (competencyIndex === -1) {
                    console.error("Could not find competency index for key:", currentQuestion.competencyKey); return;
                }
                if (answers[currentQuestion.type] && competencyIndex < answers[currentQuestion.type].length) {
                     answers[currentQuestion.type][competencyIndex] = selectedValue;
                } else {
                    console.error(`Answer type ${currentQuestion.type} or index ${competencyIndex} out of bounds. Answers array for type:`, answers[currentQuestion.type]);
                }

                if (currentIndex < questionsData.length - 1) {
                    currentIndex++;
                    renderQuestion(currentIndex);
                } else {
                    // console.log("Last question answered, calling showResults()");
                    showResults();
                }
            };
        });
    }
    
    function showResults() {
        // console.log("showResults() function CALLED");
        if(progressBar) progressBar.style.width = "100%";
        if(progressLabel) progressLabel.textContent = `100${t('assessmentScreen.progressLabelSuffix')}`;
        if(assessmentScreen) assessmentScreen.classList.add("hidden");
        if(startScreen) startScreen.classList.add("hidden");
        if(endScreen) endScreen.classList.remove("hidden");

        const today = new Date();
        const currentDay = String(today.getDate()).padStart(2, '0');
        const currentMonth = String(today.getMonth() + 1).padStart(2, '0');
        const currentYear = today.getFullYear();
        const formattedCurrentDate = `${currentDay}/${currentMonth}/${currentYear}`;
        setText('current-date-advanced', formattedCurrentDate);

        // console.log("Attempting to call generateResultsPageContent() from showResults");
        generateResultsPageContent(); // This will also call applyTranslations for its parts
        // console.log("Finished calling generateResultsPageContent() from showResults");
        
        const totalScore = (answers.Knowledge.reduce((a,b)=>a+b,0)||0) + (answers.Skills.reduce((a,b)=>a+b,0)||0) + (answers.Attitudes.reduce((a,b)=>a+b,0)||0);
        const maxScore = (competenciesData.length || 0) * 3 * 5;
        const percentageScore = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0;
        let userProficiencyLevelText = "";
        let userKeyCharacteristics = [];
        let userFeedback = "";

        for (let level of overallProficiencyLevelsData) {
            if (percentageScore >= level.range[0] && percentageScore <= level.range[1]) {
                const levelName = t(`proficiencyTexts.${level.nameKey}`);
                userProficiencyLevelText = `${levelName} (${level.range[0]}% - ${level.range[1]}%)`;
                userKeyCharacteristics = level.characteristicsKeys.map(key => t(`proficiencyTexts.${key}`));
                userFeedback = t(`proficiencyTexts.${level.feedbackKey}`);
                break;
            }
        }
        setText('total-score-advanced', `${percentageScore}% (${userProficiencyLevelText.split(' ')[0] || 'N/A'})`);
        displayKeyCharacteristics(userKeyCharacteristics);
        setText('personalised-feedback-advanced', userFeedback);
        const encodedData = encodeResponses();
        if (document.getElementById('qr-code')) { 
            generateQRCode(encodedData, 'qr-code');
        }
        updateQRCodeURL(encodedData);
        
        // Explicitly re-apply translations for static parts of the end screen
        // as generateResultsPageContent only handles dynamic sections
        setText('end-screen-title', t('endScreen.title'));
        setText('qr-code-title', t('endScreen.qrCodeSectionTitle'));
        setText('qr-code-instruction', t('endScreen.qrCodeInstruction'));
        setText('key-char-title', t('endScreen.keyCharacteristicsTitle'));
        setText('key-char-intro', t('endScreen.keyCharacteristicsIntro'));
        setText('radar-chart-title', t('endScreen.radarChartTitle'));
        setText('radar-chart-desc', t('endScreen.radarChartDescription'));
        setHTML('radar-chart-legend', constructRadarLegend());
        setHTML('strengths-title', t('endScreen.strengthsSectionTitle'));
        setText('strengths-intro', t('endScreen.strengthsSectionIntro'));
        setHTML('growth-areas-title', t('endScreen.growthAreasSectionTitle'));
        setText('growth-areas-intro', t('endScreen.growthAreasSectionIntro'));
        setHTML('smart-objectives-title', t('endScreen.smartObjectivesSectionTitle'));
        setText('smart-objectives-intro', t('endScreen.smartObjectivesSectionIntro'));
        setHTML('thank-you-message', t('endScreen.thankYouMessage'));
        setText('survey-prompt', t('endScreen.surveyPrompt'));
        setText('survey-button', t('endScreen.surveyButtonText'));
        if (restartButton) setText('restart-button', t('endScreen.restartButtonText'));
    }

    function encodeResponses() {
        const numCompetencies = competenciesData.length || 0;
        const knowledge = (answers.Knowledge || []).slice(0, numCompetencies).join('');
        const skills = (answers.Skills || []).slice(0, numCompetencies).join('');
        const attitudes = (answers.Attitudes || []).slice(0, numCompetencies).join('');
        return `${knowledge}-${skills}-${attitudes}`;
    }

    function decodeAndLoadResults() {
        // console.log("decodeAndLoadResults CALLED");
        const data = new URLSearchParams(window.location.search).get('data');
        if (data) {
            // console.log("Data found in URL, attempting to process.");
            const parts = data.split('-');
            if (parts.length === 3 && competenciesData && competenciesData.length > 0) {
                const [knowledgeStr, skillsStr, attitudesStr] = parts;
                const numCompetencies = competenciesData.length;
                answers.Knowledge = knowledgeStr.split('').map(Number).slice(0, numCompetencies);
                answers.Skills = skillsStr.split('').map(Number).slice(0, numCompetencies);
                answers.Attitudes = attitudesStr.split('').map(Number).slice(0, numCompetencies);
                while (answers.Knowledge.length < numCompetencies) answers.Knowledge.push(0);
                while (answers.Skills.length < numCompetencies) answers.Skills.push(0);
                while (answers.Attitudes.length < numCompetencies) answers.Attitudes.push(0);
                // console.log("Successfully decoded URL data, calling showResults() from decodeAndLoadResults");
                showResults();
            } else if (!competenciesData || competenciesData.length === 0) {
                 console.warn("Attempted to decode results but competenciesData not ready. URL data ignored for now.");
            } else {
                console.warn("Decoded data from URL is malformed.");
            }
        } else {
            //  console.log("No data in URL for decodeAndLoadResults.");
        }
    }

    function displayKeyCharacteristics(characteristics) {
        const listEl = document.getElementById('key-characteristics-advanced');
        if(!listEl) return;
        listEl.innerHTML = '';
        characteristics.forEach(characteristic => {
            const li = document.createElement('li');
            li.textContent = characteristic;
            listEl.appendChild(li);
        });
    }

    function generateResultsPageContent() {
        // console.log("generateResultsPageContent() CALLED");
        // console.log("competenciesData at start of generateResultsPageContent:", JSON.parse(JSON.stringify(competenciesData)));
        // console.log("Answers at start of generateResultsPageContent:", JSON.parse(JSON.stringify(answers)));

        if (!competenciesData || competenciesData.length === 0) {
            console.error("Cannot generate results content, competenciesData is empty or null.");
            return;
        }
        const competencyScores = competenciesData.map((comp, i) => {
            const knowledgeScore = answers.Knowledge[i] || 0;
            const skillsScore = answers.Skills[i] || 0;
            const attitudesScore = answers.Attitudes[i] || 0;
            const total = knowledgeScore + skillsScore + attitudesScore;
            return { key: comp.key, name: comp.name, knowledgeScore, skillsScore, attitudesScore, total };
        });
        const sortedDesc = [...competencyScores].sort((a, b) => b.total - a.total);
        const sortedAsc = [...competencyScores].sort((a, b) => a.total - b.total);
        
        const topCompetencies = sortedDesc.slice(0, 3);
        const bottomCompetencies = sortedAsc.slice(0, 3);

        // console.log("Top competencies for strengths:", JSON.parse(JSON.stringify(topCompetencies)));
        generateStrengths(topCompetencies); 

        // console.log("Bottom competencies for growth:", JSON.parse(JSON.stringify(bottomCompetencies)));
        generateGrowthAreas(bottomCompetencies);

        // console.log("Generating Radar Chart from generateResultsPageContent");
        generateRadarChart();

        // console.log("Bottom competencies for SMART:", JSON.parse(JSON.stringify(bottomCompetencies)));
        generateSmartObjectives(bottomCompetencies);
    }

    function getStrongestDimension(comp) {
        const scores = [
            { dimension: "Knowledge", score: comp.knowledgeScore || 0 },
            { dimension: "Skills", score: comp.skillsScore || 0 },
            { dimension: "Attitudes", score: comp.attitudesScore || 0 }
        ];
        scores.sort((a, b) => b.score - a.score);
        return scores[0].dimension;
    }

    function getWeakestDimension(comp) {
        const scores = [
            { dimension: "Knowledge", score: comp.knowledgeScore || 0 },
            { dimension: "Skills", score: comp.skillsScore || 0 },
            { dimension: "Attitudes", score: comp.attitudesScore || 0 }
        ];
        scores.sort((a, b) => a.score - b.score);
        return scores[0].dimension;
    }

    function getFeedbackForCompetency(competencyKey, dimension) {
        return t(`feedbackStrengths.${competencyKey}.${dimension}`);
    }
    function getGrowthFeedbackForCompetency(competencyKey, dimension) {
        return t(`feedbackGrowth.${competencyKey}.${dimension}`);
    }
    function getSmartObjective(competencyKey, dimension) {
        return t(`smartObjectives.${competencyKey}.${dimension}`);
    }

    function generateStrengths(topCompetencies) {
        // console.log("--- Strength Generation --- (Inside generateStrengths) CALLED with topCompetencies:", JSON.parse(JSON.stringify(topCompetencies)));
        if (!strengthsContainer) { console.error("strengthsContainer is null"); return; }
        strengthsContainer.innerHTML = '';
        topCompetencies.forEach(comp => {
            const strongestDimension = getStrongestDimension(comp);
            const competencyName = comp.name; // Already translated if competenciesData from JSON uses translated names
            const strengthLabel = t('endScreen.strongestDimensionLabel');
            const translatedDimensionName = t(`endScreen.radarChartLegend${strongestDimension}`);
            const feedbackText = getFeedbackForCompetency(comp.key, strongestDimension);
            // console.log("Strength Debug - HTML Segment to be added:", `...${translatedDimensionName}...`); // Simplified log

            strengthsContainer.innerHTML += `
                <div class="strength-item card">
                    <h4>${competencyName}</h4>
                    <p><strong>${strengthLabel}</strong> ${translatedDimensionName}</p>
                    <p>${feedbackText}</p>
                </div>`;
        });
    }

    function generateGrowthAreas(bottomCompetencies) {
        if (!growthAreasContainer) { console.error("growthAreasContainer is null"); return; }
        growthAreasContainer.innerHTML = '';
        bottomCompetencies.forEach(comp => {
            const weakestDimension = getWeakestDimension(comp);
            const competencyName = comp.name;
            const growthLabel = t('endScreen.growthAreaLabel');
            const translatedDimensionName = t(`endScreen.radarChartLegend${weakestDimension}`);
            const feedbackText = getGrowthFeedbackForCompetency(comp.key, weakestDimension);
            // console.log("Growth Debug - HTML Segment to be added:", `...${translatedDimensionName}...`);

            growthAreasContainer.innerHTML += `
                <div class="growth-item card">
                    <h4>${competencyName}</h4>
                    <p><strong>${growthLabel}</strong> ${translatedDimensionName}</p>
                    <p>${feedbackText}</p>
                </div>`;
        });
    }

    function generateSmartObjectives(bottomCompetencies) {
        if (!smartObjectivesContainer) { console.error("smartObjectivesContainer is null"); return; }
        smartObjectivesContainer.innerHTML = '';
        bottomCompetencies.forEach(comp => {
            const weakestDimension = getWeakestDimension(comp);
            const competencyName = comp.name;
            const growthLabel = t('endScreen.growthAreaLabel');
            const smartObjectiveLabel = t('endScreen.smartObjectiveLabel');
            const translatedDimensionNameForSMART = t(`endScreen.radarChartLegend${weakestDimension}`);
            const smartObjectiveText = getSmartObjective(comp.key, weakestDimension);
            const userLevel = comp[`${weakestDimension.toLowerCase()}Score`];
            let levelsToShow = userLevel ? (userLevel === 1 ? [1,2,3] : (userLevel === 5 ? [3,4,5] : [userLevel-1, userLevel, userLevel+1].filter(l=>l>=1 && l<=5))) : [1,2,3];
            
            const competencyForResourceLookupObj = competenciesData.find(c => c.key === comp.key);
            const competencyForResourceLookup = competencyForResourceLookupObj ? competencyForResourceLookupObj.name : comp.name;

            const filteredResources = (window.resources || []).filter(r => r.competency === competencyForResourceLookup && r.level === weakestDimension.toLowerCase());
            const chosenResources = filteredResources.filter(r => levelsToShow.includes(r.rating)).slice(0, 3);
            let resourcesHTML = '';
            if (chosenResources.length > 0) {
                resourcesHTML = `
                    <h5>${t('endScreen.recommendedResourcesLabel')}</h5>
                    <ul style="list-style:none; padding:0; margin:10px 0;">
                        ${chosenResources.map(r => `<li><a href="${r.URL}" target="_blank" style="text-decoration:none; color:#0f777b;"><strong>${r.title}</strong>: ${r.description}</a></li>`).join('')}
                    </ul>`;
            }
            // console.log("SMART Debug - HTML Segment to be added:", `...${translatedDimensionNameForSMART}...`);

            smartObjectivesContainer.innerHTML += `
                <div class="smart-item card">
                    <h4>${competencyName}</h4>
                    <p><strong>${growthLabel}</strong> ${translatedDimensionNameForSMART}</p>
                    <p><strong>${smartObjectiveLabel}</strong> ${smartObjectiveText}</p>
                    ${resourcesHTML}
                </div>`;
        });
    }

    function generateRadarChart() {
        if (radarChart) radarChart.destroy();
        if (!competenciesData || competenciesData.length === 0 || !document.getElementById('competencyRadarChart')) return;
        const radarLabels = competenciesData.map(c => c.name); 
        const data = {
            labels: radarLabels,
            datasets: [
                { label: t('endScreen.radarChartLegendKnowledge'), data: answers.Knowledge, fill: true, backgroundColor: 'rgba(255,99,132,0.2)', borderColor: 'rgb(255,99,132)', pointBackgroundColor: 'rgb(255,99,132)', borderWidth: 1 },
                { label: t('endScreen.radarChartLegendSkills'), data: answers.Skills, fill: true, backgroundColor: 'rgba(54,162,235,0.2)', borderColor: 'rgb(54,162,235)', pointBackgroundColor: 'rgb(54,162,235)', borderWidth: 1 },
                { label: t('endScreen.radarChartLegendAttitudes'), data: answers.Attitudes, fill: true, backgroundColor: 'rgba(75,192,192,0.2)', borderColor: 'rgb(75,192,192)', pointBackgroundColor: 'rgb(75,192,192)', borderWidth: 1 }
            ]
        };
        const radarCtx = document.getElementById('competencyRadarChart').getContext('2d');
        radarChart = new Chart(radarCtx, {
            type: 'radar', data: data,
            options: { responsive: true, maintainAspectRatio: true, elements: { line: { tension: 0.1 } }, scales: { r: { angleLines: { display: false }, suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1, beginAtZero: true, backdropColor: 'transparent' } } } }
        });
    }
    
    function addEventListenersToButtons() {
        if (restartButton) {
            restartButton.addEventListener("click", () => {
                currentIndex = 0;
                if (competenciesData && competenciesData.length > 0) {
                    const numCompetencies = competenciesData.length;
                    answers.Knowledge = Array(numCompetencies).fill(0);
                    answers.Skills = Array(numCompetencies).fill(0);
                    answers.Attitudes = Array(numCompetencies).fill(0);
                }
                if(endScreen) endScreen.classList.add("hidden");
                if(assessmentScreen) assessmentScreen.classList.add("hidden");
                if(startScreen) startScreen.classList.remove("hidden");
                if (radarChart) { radarChart.destroy(); radarChart = null; }
                const qrCodeCanvas = document.getElementById('qr-code');
                if (qrCodeCanvas && qrCodeCanvas.getContext) qrCodeCanvas.getContext('2d').clearRect(0, 0, qrCodeCanvas.width, qrCodeCanvas.height);
                setText('qr-url', '');
                if(strengthsContainer) strengthsContainer.innerHTML = '';
                if(growthAreasContainer) growthAreasContainer.innerHTML = '';
                if(smartObjectivesContainer) smartObjectivesContainer.innerHTML = '';
                applyTranslations(); 
            });
        } else {
            console.error("Restart button not found");
        }

        if (startButton) {
            startButton.addEventListener("click", () => {
                if(startScreen) startScreen.classList.add("hidden");
                if(assessmentScreen) assessmentScreen.classList.remove("hidden");
                if (competenciesData && competenciesData.length > 0) {
                    const numCompetencies = competenciesData.length;
                    answers.Knowledge = Array(numCompetencies).fill(0);
                    answers.Skills = Array(numCompetencies).fill(0);
                    answers.Attitudes = Array(numCompetencies).fill(0);
                    currentIndex = 0; 
                    renderQuestion(currentIndex);
                } else {
                    console.error("Cannot start assessment, competencies data not loaded.");
                }
            });
        } else {
            console.error("Start button not found");
        }
    }

    function updateQRCodeURL(data) {
        const resultsURL = `${window.location.origin}${window.location.pathname}?data=${data}`;
        setText('qr-url', resultsURL);
    }

    function generateQRCode(data, canvasId) {
        const qrCodeCanvas = document.getElementById(canvasId);
        if (!qrCodeCanvas) { console.error(`Canvas ${canvasId} not found.`); return; }
        const resultsURL = `${window.location.origin}${window.location.pathname}?data=${data}`;
        QRCode.toCanvas(qrCodeCanvas, resultsURL, { width: 200, margin: 2 }, err => {
            if (err) console.error(`Error QR code for ${canvasId}:`, err);
        });
    }

    function toggleDropdown(event) {
        const button = event.target;
        const dropdownContent = document.getElementById('proficiency-dropdown-content');
        if (dropdownContent) {
            const isHidden = dropdownContent.style.display === "none" || dropdownContent.style.display === "";
            dropdownContent.style.display = isHidden ? "block" : "none";
            button.textContent = t(isHidden ? 'assessmentScreen.hideProficiencyLevelsButton' : 'assessmentScreen.showProficiencyLevelsButton');
        }
    }
    
    async function initializeApp() {
        console.log("initializeApp CALLED");
        assignDOMelements(); 

        if (langSelectorElement) {
            langSelectorElement.addEventListener('change', async (event) => {
                const newLang = event.target.value;
                console.log(`Language dropdown changed to: ${newLang}.`);
                await loadTranslations(newLang); 

                if (startScreen && !startScreen.classList.contains('hidden') && assessmentScreen && assessmentScreen.classList.contains('hidden') && endScreen && endScreen.classList.contains('hidden')) {
                    // On start screen, applyTranslations called by loadTranslations is enough
                } else { 
                    console.log("Language changed mid-process, simulating restart.");
                    if (restartButton) restartButton.click(); 
                }
            });
        } else {
            console.warn("Language selector element 'language-selector' not found.");
        }

        addEventListenersToButtons();

        const preferredLang = localStorage.getItem('selectedUserLanguage') || navigator.language || navigator.userLanguage || 'en';
        await loadTranslations(preferredLang); 
        
        decodeAndLoadResults(); 
        console.log("initializeApp COMPLETED");
    }

    document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>

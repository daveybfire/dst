<script>
    let i18nData = {};
    let currentSelectedLang = 'en';
    let questionsData = [];
    let competenciesData = [];
    let overallProficiencyLevelsData = [];

    // DEFINE setText and setHTML EARLIER
    function setText(id, text) {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
        // else console.warn(`Element with ID ${id} not found for setText: ${text}`);
    }

    function setHTML(id, html) {
        const el = document.getElementById(id);
        if (el) el.innerHTML = html;
        // else console.warn(`Element with ID ${id} not found for setHTML: ${html}`);
    }

    // ROBUST t() function (remains the same)
    function t(key, replacements = {}) {
        if (typeof i18nData !== 'object' || i18nData === null) {
            // console.warn(`i18nData not an object or is null when looking for key: ${key}`);
            return `MISSING_I18NDATA: ${key}`;
        }
        let textValue = i18nData;
        const parts = key.split('.');
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (textValue && typeof textValue === 'object' && Object.prototype.hasOwnProperty.call(textValue, part)) {
                textValue = textValue[part];
            } else {
                // console.warn(`Translation key path broken at '${part}' for key: ${key}`);
                return `MISSING_TRANSLATION: ${key}`; 
            }
        }
        if (typeof textValue !== 'string') {
            // console.warn(`Translation for key '${key}' is not a string:`, textValue);
            return `INVALID_TRANSLATION_TYPE: ${key}`;
        }
        let finalText = textValue;
        for (const placeholder in replacements) {
            finalText = finalText.replace(new RegExp(`{${placeholder}}`, 'g'), replacements[placeholder]);
        }
        return finalText;
    }

    async function loadTranslations(langCodeToTry) {
        // ... (rest of loadTranslations function as it was) ...
        // IT CALLS applyTranslations() AT THE END OF THE TRY BLOCK
    // ... (this function is now defined)
        console.log(`loadTranslations CALLED for lang: ${langCodeToTry}`);
        let langToLoad = langCodeToTry.toLowerCase().split('-')[0]; 
        if (langCodeToTry.toLowerCase() === 'zh-hans') langToLoad = 'zh-hans';
        if (langCodeToTry.toLowerCase() === 'zh-hant') langToLoad = 'zh-hant';
        
        let response;

        try {
            response = await fetch(`${langToLoad}.json?v=${new Date().getTime()}`);
            if (!response.ok) {
                console.warn(`Could not load ${langToLoad}.json (Status: ${response.status}). Falling back to English.`);
                if (langToLoad === 'en') { 
                    throw new Error('Critical: Failed to load en.json. Application cannot start.');
                }
                langToLoad = 'en'; 
                response = await fetch(`en.json?v=${new Date().getTime()}`);
                if (!response.ok) {
                    throw new Error('Critical: Failed to load en.json as fallback. Application cannot start.');
                }
            }
            i18nData = await response.json();
            // console.log('Successfully loaded i18nData for:', langToLoad, JSON.parse(JSON.stringify(i18nData))); // Keep for debugging if needed
            
            currentSelectedLang = langToLoad; 
            document.documentElement.lang = currentSelectedLang;
            document.title = t('appTitle'); 

            questionsData = i18nData.questions || [];
            competenciesData = i18nData.competencyList || [];
            overallProficiencyLevelsData = i18nData.overallProficiencyLevels || [];
            
            if (competenciesData && competenciesData.length > 0) {
                const numCompetencies = competenciesData.length;
                answers.Knowledge = Array(numCompetencies).fill(0);
                answers.Skills = Array(numCompetencies).fill(0);
                answers.Attitudes = Array(numCompetencies).fill(0);
                // console.log("Answers arrays initialized/reset in loadTranslations. Length:", numCompetencies);
            } else {
                console.error("Competencies data is empty. Answers not initialized.");
            }

            applyTranslations(); 
            updateLanguageSelectorValue(currentSelectedLang); 
            localStorage.setItem('selectedUserLanguage', currentSelectedLang); 

            console.log(`${currentSelectedLang.toUpperCase()} translations applied.`);

        } catch (error) {
            console.error("Fatal error loading translation file:", error);
            document.body.innerHTML = `<div style="padding: 20px; text-align: center; font-family: sans-serif;"><h1>Error</h1><p>Could not load required resources. Please try again. Details: ${error.message}</p></div>`;
        }
    }
    
    function updateLanguageSelectorValue(langCode) {
        const selector = document.getElementById('language-selector');
        if (selector) {
            selector.value = langCode;
            const label = document.getElementById('language-selector-label');
            if (label) { // Ensure label exists
                const labelText = t('misc.languageLabel');
                label.textContent = labelText.startsWith('MISSING_') ? 'Language:' : labelText;
            }
        }
    }

    function applyTranslations() {
        // console.log("applyTranslations CALLED for lang:", currentSelectedLang); // Keep for debugging if needed
        // Page title is set in loadTranslations now
        setText('start-screen-title', t('startScreen.title'));
        setHTML('start-screen-p1', t('startScreen.introParagraph1'));
        setHTML('start-screen-p2', t('startScreen.introParagraph2'));
        setHTML('start-screen-p3', t('startScreen.introParagraph3'));
        setHTML('start-screen-p4', t('startScreen.introParagraph4'));
        setText('start-button', t('startScreen.startButtonText'));
        setText('no-selection-warning', t('assessmentScreen.noSelectionWarning'));
        
        const toggleProfButton = document.getElementById('toggle-proficiency-button');
        if (toggleProfButton) {
            const proficiencyDropdownEl = document.getElementById('proficiency-dropdown-content');
            if (proficiencyDropdownEl && (proficiencyDropdownEl.style.display === "none" || proficiencyDropdownEl.style.display === "")) {
                toggleProfButton.textContent = t('assessmentScreen.showProficiencyLevelsButton');
            } else if (proficiencyDropdownEl) {
                toggleProfButton.textContent = t('assessmentScreen.hideProficiencyLevelsButton');
            }
        }

        const proficiencyDropdown = document.getElementById('proficiency-dropdown-content');
        if (proficiencyDropdown) {
            proficiencyDropdown.innerHTML = `
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.beginner')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.developing')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.competent')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.proficient')}</p>
                <p>${t('assessmentScreen.proficiencyLevelsDropdown.expert')}</p>
            `;
        }
        populateProficiencyButtons();

        if (document.getElementById('assessment-screen') && !assessmentScreen.classList.contains('hidden') && questionsData.length > 0) {
            //  console.log("Assessment screen visible, re-rendering current question for new language.");
            renderQuestion(currentIndex); 
        }

        if (document.getElementById('end-screen') && !endScreen.classList.contains('hidden')) {
            // console.log("End screen visible, re-applying translations and re-generating results for new language.");
            setText('end-screen-title', t('endScreen.title'));
            setText('qr-code-title', t('endScreen.qrCodeSectionTitle'));
            setText('qr-code-instruction', t('endScreen.qrCodeInstruction'));
            setText('key-char-title', t('endScreen.keyCharacteristicsTitle'));
            setText('key-char-intro', t('endScreen.keyCharacteristicsIntro'));
            setText('radar-chart-title', t('endScreen.radarChartTitle'));
            setText('radar-chart-desc', t('endScreen.radarChartDescription'));
            setHTML('radar-chart-legend', constructRadarLegend());
            setHTML('strengths-title', t('endScreen.strengthsSectionTitle'));
            setText('strengths-intro', t('endScreen.strengthsSectionIntro'));
            setHTML('growth-areas-title', t('endScreen.growthAreasSectionTitle'));
            setText('growth-areas-intro', t('endScreen.growthAreasSectionIntro'));
            setHTML('smart-objectives-title', t('endScreen.smartObjectivesSectionTitle'));
            setText('smart-objectives-intro', t('endScreen.smartObjectivesSectionIntro'));
            setHTML('thank-you-message', t('endScreen.thankYouMessage'));
            setText('survey-prompt', t('endScreen.surveyPrompt'));
            setText('survey-button', t('endScreen.surveyButtonText'));
            setText('restart-button', t('endScreen.restartButtonText'));
            
            if (answers.Knowledge.length > 0 || answers.Skills.length > 0 || answers.Attitudes.length > 0) {
                 generateResultsPageContent();
            }
        }
    }

    // ... (constructRadarLegend is now defined after setText/setHTML)
    function constructRadarLegend() {
        const andConj = t('misc.andConjunction');
        const lowerThanConj = t('misc.areLowerThanConjunction');
        return `${t('endScreen.radarChartLegendIntro')}
                <span style="color: #ff6384; font-weight: bold;">${t('endScreen.radarChartLegendKnowledge')}</span>,
                <span style="color: #36a2eb; font-weight: bold;">${t('endScreen.radarChartLegendSkills')}</span>, ${andConj.startsWith('MISSING_') ? 'and' : andConj}
                <span style="color: #4bc0c0; font-weight: bold;">${t('endScreen.radarChartLegendAttitudes')}</span>
                ${t('endScreen.radarChartLegendExplanation')}
                <span style="color: #36a2eb; font-weight: bold;">${t('endScreen.radarChartLegendSkillsExample')}</span>
                ${lowerThanConj.startsWith('MISSING_') ? 'are lower than' : lowerThanConj} <span style="color: #ff6384; font-weight: bold;">${t('endScreen.radarChartLegendKnowledgeExample')}</span>
                ${t('endScreen.radarChartLegendExplanationSuffix')}`;
    }


    // ... (populateProficiencyButtons is now defined after setText/setHTML) ...
    function populateProficiencyButtons() {
        const container = document.querySelector('#assessment-screen .proficiency-buttons');
        if (!container) return;
        container.innerHTML = '';
        for (let i = 1; i <= 5; i++) {
            const button = document.createElement('button');
            button.classList.add('proficiency-button');
            button.setAttribute('data-value', i);
            button.type = 'button';
            button.textContent = t(`proficiencyLabels.${i}`); // Uses t()
            container.appendChild(button);
        }
        proficiencyButtons = document.querySelectorAll(".proficiency-button"); // Re-query
    }


    // ALL OTHER SCRIPT CONTENT REMAINS THE SAME
    // ... (answers const, DOM element consts, getCompetencyNameByKey, renderQuestion, etc. ...)
    // ... (The full script block from the previous correctly working version) ...

    const answers = { Knowledge: [], Skills: [], Attitudes: [] };
    const startScreen = document.getElementById("start-screen");
    const assessmentScreen = document.getElementById("assessment-screen");
    const endScreen = document.getElementById("end-screen");
    const progressBar = document.getElementById("progress-bar");
    const progressLabel = document.getElementById("progress-label");
    const competencyBanner = document.getElementById("competency-banner");
    const questionTextContainer = document.getElementById("question-text-container");
    const exampleTextContainer = document.getElementById("example-text-container");
    let proficiencyButtons = document.querySelectorAll(".proficiency-button");
    const noSelectionWarningEl = document.getElementById("no-selection-warning");
    const strengthsContainer = document.getElementById("strengths");
    const growthAreasContainer = document.getElementById("growth-areas");
    const smartObjectivesContainer = document.getElementById("smart-objectives");
    const restartButton = document.getElementById("restart-button");
    const startButton = document.getElementById("start-button");
    let currentIndex = 0;
    let radarChart;

    function getCompetencyNameByKey(key) {
        if (!competenciesData) return `NO_COMP_DATA_FOR_KEY: ${key}`;
        const competency = competenciesData.find(c => c.key === key);
        return competency ? competency.name : `MISSING_COMP_NAME: ${key}`;
    }

    function renderQuestion(index) {
        // console.log(`renderQuestion CALLED for index: ${index}`); // Keep for debug if needed
        if (!questionsData || questionsData.length === 0 || index >= questionsData.length) {
            console.error("Questions data issue or index out of bounds in renderQuestion.", { qDataLength: questionsData?.length, index });
            return;
        }
        const question = questionsData[index];
        const competencyName = getCompetencyNameByKey(question.competencyKey);
        const examplePrefixText = t('misc.examplePrefix');

        competencyBanner.textContent = `${t('assessmentScreen.competencyBannerPrefix')}${competencyName}`;
        questionTextContainer.textContent = t(`questionTexts.${question.questionKey}`);
        exampleTextContainer.textContent = `${examplePrefixText.startsWith("MISSING_") ? "Example: " : examplePrefixText}${t(`questionTexts.${question.exampleKey}`)}`;

        const progressPercentage = Math.round(((index + 1) / questionsData.length) * 100);
        progressBar.style.width = `${progressPercentage}%`;
        progressLabel.textContent = `${progressPercentage}${t('assessmentScreen.progressLabelSuffix')}`;
        
        proficiencyButtons = document.querySelectorAll("#assessment-screen .proficiency-button");
        proficiencyButtons.forEach(button => button.classList.remove("selected"));
        
        if(noSelectionWarningEl) noSelectionWarningEl.style.display = 'none';
        attachEventListeners();
    }

    function attachEventListeners() {
        // console.log("attachEventListeners CALLED"); // Keep for debug if needed
        proficiencyButtons = document.querySelectorAll("#assessment-screen .proficiency-button");
        
        proficiencyButtons.forEach(button => {
            const newButton = button.cloneNode(true); 
            if (button.parentNode) {
                button.parentNode.replaceChild(newButton, button);
            }
        });
        proficiencyButtons = document.querySelectorAll("#assessment-screen .proficiency-button"); 

        proficiencyButtons.forEach(button => {
            button.onclick = () => {
                if(noSelectionWarningEl) noSelectionWarningEl.style.display = 'none';
                proficiencyButtons.forEach(btn => btn.classList.remove("selected"));
                button.classList.add("selected");
                const selectedValue = parseInt(button.getAttribute("data-value"));
                const currentQuestion = questionsData[currentIndex];
                const competencyIndex = competenciesData.findIndex(c => c.key === currentQuestion.competencyKey);

                if (competencyIndex === -1) {
                    console.error("Could not find competency index for key:", currentQuestion.competencyKey); return;
                }
                if (answers[currentQuestion.type] && competencyIndex < answers[currentQuestion.type].length) {
                     answers[currentQuestion.type][competencyIndex] = selectedValue;
                } else {
                    console.error(`Answer type ${currentQuestion.type} or index ${competencyIndex} out of bounds. Answers array for type:`, answers[currentQuestion.type]);
                }

                if (currentIndex < questionsData.length - 1) {
                    currentIndex++;
                    renderQuestion(currentIndex);
                } else {
                    // console.log("Last question answered, calling showResults()"); // Keep for debug
                    showResults();
                }
            };
        });
    }
    
    // --- (The rest of the JS functions: showResults, encodeResponses, decodeAndLoadResults, etc.
    // ---  generateStrengths, generateGrowthAreas, generateSmartObjectives (with their console.logs)
    // ---  generateRadarChart, restartButton/startButton listeners, QR code fns, toggleDropdown
    // ---  should be the versions from the file you provided in message #39, 
    // ---  as those were the ones producing the correct console logs showing "Knowledge", "Skills" etc.
    // ---  for `translatedDimensionName`. I am pasting them again here for absolute completeness.)

    function showResults() {
        // console.log("showResults() function CALLED");
        if(progressBar) progressBar.style.width = "100%";
        if(progressLabel) progressLabel.textContent = `100${t('assessmentScreen.progressLabelSuffix')}`;
        if(assessmentScreen) assessmentScreen.classList.add("hidden");
        if(startScreen) startScreen.classList.add("hidden");
        if(endScreen) endScreen.classList.remove("hidden");

        const today = new Date();
        const currentDay = String(today.getDate()).padStart(2, '0');
        const currentMonth = String(today.getMonth() + 1).padStart(2, '0');
        const currentYear = today.getFullYear();
        const formattedCurrentDate = `${currentDay}/${currentMonth}/${currentYear}`;
        setText('current-date-advanced', formattedCurrentDate);

        // console.log("Attempting to call generateResultsPageContent() from showResults");
        generateResultsPageContent();
        // console.log("Finished calling generateResultsPageContent() from showResults");
        
        const totalScore = (answers.Knowledge.reduce((a, b) => a + b, 0) || 0) +
                           (answers.Skills.reduce((a, b) => a + b, 0) || 0) +
                           (answers.Attitudes.reduce((a, b) => a + b, 0) || 0) ;
        const maxScore = (competenciesData.length || 0) * 3 * 5;
        const percentageScore = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0;
        let userProficiencyLevelText = "";
        let userKeyCharacteristics = [];
        let userFeedback = "";

        for (let level of overallProficiencyLevelsData) {
            if (percentageScore >= level.range[0] && percentageScore <= level.range[1]) {
                const levelName = t(`proficiencyTexts.${level.nameKey}`);
                userProficiencyLevelText = `${levelName} (${level.range[0]}% - ${level.range[1]}%)`;
                userKeyCharacteristics = level.characteristicsKeys.map(key => t(`proficiencyTexts.${key}`));
                userFeedback = t(`proficiencyTexts.${level.feedbackKey}`);
                break;
            }
        }
        setText('total-score-advanced', `${percentageScore}% (${userProficiencyLevelText.split(' ')[0] || 'N/A'})`);
        displayKeyCharacteristics(userKeyCharacteristics);
        setText('personalised-feedback-advanced', userFeedback);
        const encodedData = encodeResponses();
        if (document.getElementById('qr-code')) { 
            generateQRCode(encodedData, 'qr-code');
        }
        updateQRCodeURL(encodedData);
    }

    function encodeResponses() {
        const numCompetencies = competenciesData.length || 0;
        const knowledge = (answers.Knowledge || []).slice(0, numCompetencies).join('');
        const skills = (answers.Skills || []).slice(0, numCompetencies).join('');
        const attitudes = (answers.Attitudes || []).slice(0, numCompetencies).join('');
        return `${knowledge}-${skills}-${attitudes}`;
    }

    function decodeAndLoadResults() {
        // console.log("decodeAndLoadResults CALLED");
        const data = new URLSearchParams(window.location.search).get('data');
        if (data) {
            // console.log("Data found in URL, attempting to process.");
            const parts = data.split('-');
            if (parts.length === 3 && competenciesData && competenciesData.length > 0) {
                const [knowledgeStr, skillsStr, attitudesStr] = parts;
                const numCompetencies = competenciesData.length;
                answers.Knowledge = knowledgeStr.split('').map(Number).slice(0, numCompetencies);
                answers.Skills = skillsStr.split('').map(Number).slice(0, numCompetencies);
                answers.Attitudes = attitudesStr.split('').map(Number).slice(0, numCompetencies);
                while (answers.Knowledge.length < numCompetencies) answers.Knowledge.push(0);
                while (answers.Skills.length < numCompetencies) answers.Skills.push(0);
                while (answers.Attitudes.length < numCompetencies) answers.Attitudes.push(0);
                // console.log("Successfully decoded URL data, calling showResults() from decodeAndLoadResults");
                showResults();
            } else if (!competenciesData || competenciesData.length === 0) {
                 console.warn("Attempted to decode results but competenciesData not ready. URL data ignored for now.");
            } else {
                console.warn("Decoded data from URL is malformed.");
            }
        } else {
            //  console.log("No data in URL for decodeAndLoadResults.");
        }
    }

    function displayKeyCharacteristics(characteristics) {
        const listEl = document.getElementById('key-characteristics-advanced');
        if(!listEl) return;
        listEl.innerHTML = '';
        characteristics.forEach(characteristic => {
            const li = document.createElement('li');
            li.textContent = characteristic;
            listEl.appendChild(li);
        });
    }

    function generateResultsPageContent() {
        // console.log("generateResultsPageContent() CALLED");
        // console.log("competenciesData at start of generateResultsPageContent:", JSON.parse(JSON.stringify(competenciesData)));
        // console.log("Answers at start of generateResultsPageContent:", JSON.parse(JSON.stringify(answers)));

        if (!competenciesData || competenciesData.length === 0) {
            console.error("Cannot generate results content, competenciesData is empty or null.");
            return;
        }
        const competencyScores = competenciesData.map((comp, i) => {
            const knowledgeScore = answers.Knowledge[i] || 0;
            const skillsScore = answers.Skills[i] || 0;
            const attitudesScore = answers.Attitudes[i] || 0;
            const total = knowledgeScore + skillsScore + attitudesScore;
            return { key: comp.key, name: comp.name, knowledgeScore, skillsScore, attitudesScore, total };
        });
        const sortedDesc = [...competencyScores].sort((a, b) => b.total - a.total);
        const sortedAsc = [...competencyScores].sort((a, b) => a.total - b.total);
        
        const topCompetencies = sortedDesc.slice(0, 3);
        const bottomCompetencies = sortedAsc.slice(0, 3);

        // console.log("Top competencies for strengths:", JSON.parse(JSON.stringify(topCompetencies)));
        generateStrengths(topCompetencies); 

        // console.log("Bottom competencies for growth:", JSON.parse(JSON.stringify(bottomCompetencies)));
        generateGrowthAreas(bottomCompetencies);

        // console.log("Generating Radar Chart from generateResultsPageContent");
        generateRadarChart();

        // console.log("Bottom competencies for SMART:", JSON.parse(JSON.stringify(bottomCompetencies)));
        generateSmartObjectives(bottomCompetencies);
    }

    function getStrongestDimension(comp) {
        const scores = [
            { dimension: "Knowledge", score: comp.knowledgeScore || 0 },
            { dimension: "Skills", score: comp.skillsScore || 0 },
            { dimension: "Attitudes", score: comp.attitudesScore || 0 }
        ];
        scores.sort((a, b) => b.score - a.score);
        return scores[0].dimension;
    }

    function getWeakestDimension(comp) {
        const scores = [
            { dimension: "Knowledge", score: comp.knowledgeScore || 0 },
            { dimension: "Skills", score: comp.skillsScore || 0 },
            { dimension: "Attitudes", score: comp.attitudesScore || 0 }
        ];
        scores.sort((a, b) => a.score - b.score);
        return scores[0].dimension;
    }

    function getFeedbackForCompetency(competencyKey, dimension) {
        return t(`feedbackStrengths.${competencyKey}.${dimension}`);
    }
    function getGrowthFeedbackForCompetency(competencyKey, dimension) {
        return t(`feedbackGrowth.${competencyKey}.${dimension}`);
    }
    function getSmartObjective(competencyKey, dimension) {
        return t(`smartObjectives.${competencyKey}.${dimension}`);
    }

    function generateStrengths(topCompetencies) {
        // console.log("--- Strength Generation --- (Inside generateStrengths) CALLED with topCompetencies:", JSON.parse(JSON.stringify(topCompetencies)));
        if (!strengthsContainer) { console.error("strengthsContainer is null"); return; }
        strengthsContainer.innerHTML = '';
        topCompetencies.forEach(comp => {
            const strongestDimension = getStrongestDimension(comp);
            const competencyName = comp.name;
            const strengthLabel = t('endScreen.strongestDimensionLabel');
            
            // console.log("Strength Debug - Comp:", competencyName, "Raw Strongest Dim:", strongestDimension);
            const lookupKey = `endScreen.radarChartLegend${strongestDimension}`;
            // console.log("Strength Debug - Lookup Key:", lookupKey);
            
            const translatedDimensionName = t(lookupKey);
            // console.log("Strength Debug - Translated Dim Name for HTML:", translatedDimensionName, "(Type:", typeof translatedDimensionName + ")");

            const feedbackText = getFeedbackForCompetency(comp.key, strongestDimension);

            const htmlSegment = `
                <div class="strength-item card">
                    <h4>${competencyName}</h4>
                    <p><strong>${strengthLabel}</strong> ${translatedDimensionName}</p>
                    <p>${feedbackText}</p>
                </div>`;
            
            // console.log("Strength Debug - HTML Segment to be added:", htmlSegment);

            try {
                strengthsContainer.innerHTML += htmlSegment;
            } catch (e) {
                console.error("Error during innerHTML update for strengths:", e, "Segment was:", htmlSegment);
            }
        });
    }

    function generateGrowthAreas(bottomCompetencies) {
        // console.log("--- Growth Area Generation --- (Inside generateGrowthAreas) CALLED with bottomCompetencies:", JSON.parse(JSON.stringify(bottomCompetencies)));
        if (!growthAreasContainer) { console.error("growthAreasContainer is null"); return; }
        growthAreasContainer.innerHTML = '';
        bottomCompetencies.forEach(comp => {
            const weakestDimension = getWeakestDimension(comp);
            const competencyName = comp.name;
            const growthLabel = t('endScreen.growthAreaLabel');

            // console.log("Growth Debug - Comp:", competencyName, "Raw Weakest Dim:", weakestDimension);
            const lookupKey = `endScreen.radarChartLegend${weakestDimension}`;
            // console.log("Growth Debug - Lookup Key:", lookupKey);

            const translatedDimensionName = t(lookupKey);
            // console.log("Growth Debug - Translated Dim Name for HTML:", translatedDimensionName, "(Type:", typeof translatedDimensionName + ")");
            
            const feedbackText = getGrowthFeedbackForCompetency(comp.key, weakestDimension);

            const htmlSegment = `
                <div class="growth-item card">
                    <h4>${competencyName}</h4>
                    <p><strong>${growthLabel}</strong> ${translatedDimensionName}</p>
                    <p>${feedbackText}</p>
                </div>`;

            // console.log("Growth Debug - HTML Segment to be added:", htmlSegment);
            
            try {
                growthAreasContainer.innerHTML += htmlSegment;
            } catch (e) {
                console.error("Error during innerHTML update for growth areas:", e, "Segment was:", htmlSegment);
            }
        });
    }

    function generateSmartObjectives(bottomCompetencies) {
        // console.log("--- SMART Objective Generation --- (Inside generateSmartObjectives) CALLED with bottomCompetencies:", JSON.parse(JSON.stringify(bottomCompetencies)));
        if (!smartObjectivesContainer) { console.error("smartObjectivesContainer is null"); return; }
        smartObjectivesContainer.innerHTML = '';
        bottomCompetencies.forEach(comp => {
            const weakestDimension = getWeakestDimension(comp);
            const competencyName = comp.name;
            const growthLabel = t('endScreen.growthAreaLabel');
            const smartObjectiveLabel = t('endScreen.smartObjectiveLabel');

            // console.log("SMART Debug - Comp:", competencyName, "Raw Weakest Dim:", weakestDimension);
            const dimensionNameLookupKey = `endScreen.radarChartLegend${weakestDimension}`;
            // console.log("SMART Debug - Lookup Key for Dim Name:", dimensionNameLookupKey);

            const translatedDimensionNameForSMART = t(dimensionNameLookupKey);
            // console.log("SMART Debug - Translated Dim Name for HTML:", translatedDimensionNameForSMART, "(Type:", typeof translatedDimensionNameForSMART + ")");
            
            const smartObjectiveText = getSmartObjective(comp.key, weakestDimension);
            const userLevel = comp[`${weakestDimension.toLowerCase()}Score`];
            let levelsToShow = userLevel ? (userLevel === 1 ? [1,2,3] : (userLevel === 5 ? [3,4,5] : [userLevel-1, userLevel, userLevel+1].filter(l=>l>=1 && l<=5))) : [1,2,3];
            const competencyForResourceLookup = competenciesData.find(c => c.key === comp.key)?.name;
            const filteredResources = (window.resources || []).filter(r => r.competency === competencyForResourceLookup && r.level === weakestDimension.toLowerCase());
            const chosenResources = filteredResources.filter(r => levelsToShow.includes(r.rating)).slice(0, 3);
            let resourcesHTML = '';
            if (chosenResources.length > 0) {
                resourcesHTML = `
                    <h5>${t('endScreen.recommendedResourcesLabel')}</h5>
                    <ul style="list-style:none; padding:0; margin:10px 0;">
                        ${chosenResources.map(r => `<li><a href="${r.URL}" target="_blank" style="text-decoration:none; color:#0f777b;"><strong>${r.title}</strong>: ${r.description}</a></li>`).join('')}
                    </ul>`;
            }

            const htmlSegment = `
                <div class="smart-item card">
                    <h4>${competencyName}</h4>
                    <p><strong>${growthLabel}</strong> ${translatedDimensionNameForSMART}</p>
                    <p><strong>${smartObjectiveLabel}</strong> ${smartObjectiveText}</p>
                    ${resourcesHTML}
                </div>`;
            
            // console.log("SMART Debug - HTML Segment to be added:", htmlSegment);

            try {
                smartObjectivesContainer.innerHTML += htmlSegment;
            } catch (e) {
                console.error("Error during innerHTML update for SMART objectives:", e, "Segment was:", htmlSegment);
            }
        });
    }

    function generateRadarChart() {
        if (radarChart) radarChart.destroy();
        if (!competenciesData || competenciesData.length === 0 || !document.getElementById('competencyRadarChart')) return;
        const radarLabels = competenciesData.map(c => c.name);
        const data = {
            labels: radarLabels,
            datasets: [
                { label: t('endScreen.radarChartLegendKnowledge'), data: answers.Knowledge, fill: true, backgroundColor: 'rgba(255,99,132,0.2)', borderColor: 'rgb(255,99,132)', pointBackgroundColor: 'rgb(255,99,132)', borderWidth: 1 },
                { label: t('endScreen.radarChartLegendSkills'), data: answers.Skills, fill: true, backgroundColor: 'rgba(54,162,235,0.2)', borderColor: 'rgb(54,162,235)', pointBackgroundColor: 'rgb(54,162,235)', borderWidth: 1 },
                { label: t('endScreen.radarChartLegendAttitudes'), data: answers.Attitudes, fill: true, backgroundColor: 'rgba(75,192,192,0.2)', borderColor: 'rgb(75,192,192)', pointBackgroundColor: 'rgb(75,192,192)', borderWidth: 1 }
            ]
        };
        const radarCtx = document.getElementById('competencyRadarChart').getContext('2d');
        radarChart = new Chart(radarCtx, {
            type: 'radar', data: data,
            options: { responsive: true, maintainAspectRatio: true, elements: { line: { tension: 0.1 } }, scales: { r: { angleLines: { display: false }, suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1, beginAtZero: true, backdropColor: 'transparent' } } } }
        });
    }

    restartButton.addEventListener("click", () => {
        currentIndex = 0;
        if (competenciesData && competenciesData.length > 0) {
            const numCompetencies = competenciesData.length;
            answers.Knowledge = Array(numCompetencies).fill(0);
            answers.Skills = Array(numCompetencies).fill(0);
            answers.Attitudes = Array(numCompetencies).fill(0);
        }
        if(endScreen) endScreen.classList.add("hidden");
        if(assessmentScreen) assessmentScreen.classList.add("hidden");
        if(startScreen) startScreen.classList.remove("hidden");
        if (radarChart) { radarChart.destroy(); radarChart = null; }
        const qrCodeCanvas = document.getElementById('qr-code');
        if (qrCodeCanvas && qrCodeCanvas.getContext) qrCodeCanvas.getContext('2d').clearRect(0, 0, qrCodeCanvas.width, qrCodeCanvas.height);
        setText('qr-url', '');
        if(strengthsContainer) strengthsContainer.innerHTML = '';
        if(growthAreasContainer) growthAreasContainer.innerHTML = '';
        if(smartObjectivesContainer) smartObjectivesContainer.innerHTML = '';
        applyTranslations(); 
    });

    startButton.addEventListener("click", () => {
        if(startScreen) startScreen.classList.add("hidden");
        if(assessmentScreen) assessmentScreen.classList.remove("hidden");
        if (competenciesData && competenciesData.length > 0) {
            const numCompetencies = competenciesData.length;
            answers.Knowledge = Array(numCompetencies).fill(0);
            answers.Skills = Array(numCompetencies).fill(0);
            answers.Attitudes = Array(numCompetencies).fill(0);
            currentIndex = 0; 
            renderQuestion(currentIndex);
        } else {
            console.error("Cannot start assessment, competencies data not loaded.");
        }
    });

    function updateQRCodeURL(data) {
        const resultsURL = `${window.location.origin}${window.location.pathname}?data=${data}`;
        setText('qr-url', resultsURL);
    }

    function generateQRCode(data, canvasId) {
        const qrCodeCanvas = document.getElementById(canvasId);
        if (!qrCodeCanvas) { console.error(`Canvas ${canvasId} not found.`); return; }
        const resultsURL = `${window.location.origin}${window.location.pathname}?data=${data}`;
        QRCode.toCanvas(qrCodeCanvas, resultsURL, { width: 200, margin: 2 }, err => {
            if (err) console.error(`Error QR code for ${canvasId}:`, err);
        });
    }

    function toggleDropdown(event) {
        const button = event.target;
        const dropdownContent = document.getElementById('proficiency-dropdown-content');
        if (dropdownContent) {
            const isHidden = dropdownContent.style.display === "none" || dropdownContent.style.display === "";
            dropdownContent.style.display = isHidden ? "block" : "none";
            button.textContent = t(isHidden ? 'assessmentScreen.hideProficiencyLevelsButton' : 'assessmentScreen.showProficiencyLevelsButton');
        }
    }
    
    async function initializeApp() {
        console.log("initializeApp CALLED");
        const langSelectorElement = document.getElementById('language-selector');
        if (langSelectorElement) {
            langSelectorElement.addEventListener('change', async (event) => {
                const newLang = event.target.value;
                console.log(`Language dropdown changed to: ${newLang}.`);
                await loadTranslations(newLang); 

                if (!startScreen.classList.contains('hidden') && assessmentScreen.classList.contains('hidden') && endScreen.classList.contains('hidden')) {
                    // On start screen, applyTranslations called by loadTranslations is enough
                } else { 
                    console.log("Language changed mid-process, simulating restart.");
                    if (restartButton) restartButton.click(); 
                }
            });
        } else {
            console.warn("Language selector element 'language-selector' not found.");
        }

        const preferredLang = localStorage.getItem('selectedUserLanguage') || navigator.language || navigator.userLanguage || 'en';
        await loadTranslations(preferredLang); 
        
        decodeAndLoadResults(); 
        console.log("initializeApp COMPLETED");
    }

    window.onload = initializeApp;

</script>
</body>
</html>
